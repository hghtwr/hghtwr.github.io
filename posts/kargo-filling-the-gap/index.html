<!doctype html><html lang=en><head><title>Kargo? Filling the gap! · Johannes Sonner (Hightower)
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Johannes Sonner"><meta name=description content="GitOps sounds too good to be true. The idea of syncing the state of your systems and applications from a single source of truth in Git feels so natural and intuitive. GitOps offers many advantages, like having a versioned track record of your application. However, as great as this sounds, it&rsquo;s only part of the picture.
In this article, I’ll take you on my journey to discover the missing piece in GitOps and explore a tool that might fill the gap: Kargo."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Kargo? Filling the gap!"><meta name=twitter:description content="GitOps sounds too good to be true. The idea of syncing the state of your systems and applications from a single source of truth in Git feels so natural and intuitive. GitOps offers many advantages, like having a versioned track record of your application. However, as great as this sounds, it’s only part of the picture.
In this article, I’ll take you on my journey to discover the missing piece in GitOps and explore a tool that might fill the gap: Kargo."><meta property="og:url" content="https://hghtwr.github.io/posts/kargo-filling-the-gap/"><meta property="og:site_name" content="Johannes Sonner (Hightower)"><meta property="og:title" content="Kargo? Filling the gap!"><meta property="og:description" content="GitOps sounds too good to be true. The idea of syncing the state of your systems and applications from a single source of truth in Git feels so natural and intuitive. GitOps offers many advantages, like having a versioned track record of your application. However, as great as this sounds, it’s only part of the picture.
In this article, I’ll take you on my journey to discover the missing piece in GitOps and explore a tool that might fill the gap: Kargo."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-23T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-23T11:36:11+01:00"><link rel=canonical href=https://hghtwr.github.io/posts/kargo-filling-the-gap/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://hghtwr.github.io/>Johannes Sonner (Hightower)
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/pages/about-me/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://hghtwr.github.io/posts/kargo-filling-the-gap/>Kargo? Filling the gap!</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-11-23T00:00:00Z>November 23, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
11-minute read</span></div></div></header><div class=post-content><p>GitOps sounds too good to be true. The idea of syncing the state of your systems and applications from a single source of truth in Git feels so natural and intuitive. GitOps offers many advantages, like having a versioned track record of your application. However, as great as this sounds, it&rsquo;s only part of the picture.</p><p>In this article, I’ll take you on my journey to discover the missing piece in GitOps and explore a tool that might fill the gap: <strong>Kargo</strong>. I’ll describe how I investigated Kargo and how something initially abstract and hard to grasp turned into a tool that left me with great conclusions.</p><h2 id=the-missing-piece>The Missing Piece
<a class=heading-link href=#the-missing-piece><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>But first, about the problem. GitOps tooling has matured, and the choice of tools often depends on convenience and user needs rather than functionality. A classic GitOps setup might look like the diagram below: you have two repositories—one for your application code and CI configurations, and another for your application manifests (or templates to generate them). A GitOps operator (like ArgoCD) ensures that the cluster&rsquo;s state is synchronized with the desired state defined in your repository.</p><p>For environments, whether logical or physical, you typically separate configurations in your repository. The GitOps operator then points to different branches or folders based on the target environment.</p><p><img alt="GitOps Flow" src=/posts/kargo-filling-the-gap/gitops.png>
In this example, ArgoCD monitors the <code>develop</code> branch for one environment and the <code>main</code> branch for another. This simplistic view glosses over the complexity of managing multiple environments that applications traverse before reaching production.</p><p>Ultimately, the promotion mechanism in GitOps involves either</p><ul><li>updating the Git repository to reflect the desired state for a specific environment, often through branch merges or updates to designated configuration directories, or</li><li>tagging or marking a specific commit to indicate it as the source of truth for synchronization.</li></ul><p>At its core, it&rsquo;s just a file change or a commit tag in the repository—simple, right?</p><p>This simplicity can be both compelling and dangerous. It might work in small teams or limited scopes, but imagine hundreds of developers working across hundreds of repositories daily, trying to remember which combination of commits has been deployed, tested, and is safe for production.</p><p>Imagine the following scenarios:</p><ul><li>A post-mortem meeting reveals that Laura was on vacation, and Jimmy who usually doesn&rsquo;t takes care of deploying resources accidentally tagged a commit with the wrong feature flags for production.</li><li>An incident call on a Friday night finds Bob mistakenly promoting a database schema change into production due to a mix-up in image tags.</li></ul><blockquote><p><strong>How can we safely promote our applications across environments while maintaining visibility and control? How can we track what gets deployed where, without being constrained by the linear, rigid structure of traditional deployment pipelines?</strong></p></blockquote><h2 id=the-promise>The Promise
<a class=heading-link href=#the-promise><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><strong>Kargo</strong> promises to fill this gap. It takes a while to wrap your head around but it&rsquo;s worth it. Kargo allows you to define stages, their dependencies, and track delivery artifact combinations (e.g., Helm charts and image tags) across their lifecycle. Additionally, it handles manifest generation and delivery to Git sources.
Kargo provides a user interface where users can assemble combinations of delivery artifacts (called <code>Freight</code>) and easily track what combination is deployed at each stage of their delivery process.</p><p><img alt=UI src=/posts/kargo-filling-the-gap/ui.png></p><h2 id=but-how>But How?
<a class=heading-link href=#but-how><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To do this, Kargo comes with a number of custom resources. I recommend you reading about the <a href=https://docs.kargo.io/concepts#the-basics class=external-link target=_blank rel=noopener>key concepts</a> in the Kargo documentation to learn more about what the custom resources in the picture below do.</p><p><img alt="Kargo Setup" src=/posts/kargo-filling-the-gap/kargo-setup.png>
Using a <code>Warehouse</code> Kargo creates combinations of versioned artifacts from different sources, called <code>Freight</code>. You can customize <code>Stages</code> that define the order in which <code>Freight</code> must be deployed to different <code>Stages</code>. A <code>Stage</code> is a term for a deployment of the service that fulfills a certain purpose, i.e. a user acceptance test or whatever you like. A <code>Stage</code> defines the mechanisms, by which a <code>Promotion</code> of <code>Freight</code> from a specific <code>Warehouse</code> or a previous <code>Stage</code> can be done.</p><p>Using the steps described in a <code>Stage</code>, a <code>Promotion</code> will execute the necessary actions, e.g. update the image tag in your helm chart to deliver the combination of your helm chart and individual image tag and commit the result back to your desired location in Git either by a direct commit or using a Pull Request in case you want more control about your delivery.</p><p>Last but not least, Kargo allows you to automatically perform <code>AnalysisRuns</code> to assess the health of your promoted resources. This enables you to perform extensive testing of your resources similar as in the good-old CICD pipelines.</p><h3 id=excurse-rendered-manifests-pattern>Excurse: Rendered Manifests Pattern
<a class=heading-link href=#excurse-rendered-manifests-pattern><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>In the previous paragraphs you learned that Kargo will commit back to your repository. So now, it&rsquo;s time to talk about what and why Kargo commits to your Git.
<img alt="Rendered Manifestes" src=/posts/kargo-filling-the-gap/rendered-manifests.png></p><p>Kargo emphasizes the <strong>rendered manifests pattern</strong>, which stores pre-rendered manifests directly in your Git repository instead of relying on tools like ArgoCD to render them at runtime.</p><p>Imagine a scenario where you pointed your ArgoCD Application to watch a repository containing a Helm Chart. Under the hood, ArgoCD will execute <code>helm template</code> to create the manifests. A seemingly small commit of a dependency chart in a Pull Request might lead to ArgoCD to create undesired resources in your cluster and you will not be able to tell upfront from by looking at your sources. Storing the rendered manifests in Git allows for full transparency of your desired state within Git.</p><p>Usually, you either store your rendered manifests in separate branches per environment or in different folders within a branch. In both cases, a separate destination for your manifests will also avoid conflicts on your branches.</p><p>If you want to learn more about this pattern, I&rsquo;d recommend to check this <a href=https://akuity.io/blog/the-rendered-manifests-pattern class=external-link target=_blank rel=noopener>article by Akuity</a>.</p><h3 id=warehouses--freight>Warehouses & Freight
<a class=heading-link href=#warehouses--freight><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>To achieve this, you create a <code>warehouse</code> resource in which you define the repositories to watch. In case Kargo recognizes a new commit or tag in the repositories, it will offer you to bundle it in a unique combination of your artifacts called <code>Freight</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kargo-poc</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>kargo-poc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>interval</span>: <span style=color:#ae81ff>10s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>subscriptions</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>registry.com/service-image:1.0.0</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>discoveryLimit</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>imageSelectionStrategy</span>: <span style=color:#ae81ff>SemVer</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>git</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/service-cicd.git</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>commitSelectionStrategy</span>: <span style=color:#ae81ff>SemVer</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>strictSemvers</span>: <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><p>Therefore, a <code>Freight</code> is a unique combination of references to one or more versioned artifacts from a warehouse.</p><p>Kargo lets you decide if you want it to create <code>Freight</code> from each commit or tag it identifies or only from tags using Semantic Versioning.</p><h3 id=stages>Stages
<a class=heading-link href=#stages><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>A <code>Stage</code> let&rsquo;s you define what kind of input you allow (either from a previous <code>Stage</code> or a <code>Warehouse</code>). Looking at the <code>Stage</code> below, you can see it accepts <code>Freight</code> from the a <code>Warehouse </code>called <code>kargo-poc</code> and requires it to come from a previous <code>Stage</code> called <em>teststable-tags</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kargo.akuity.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Stage</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>uat-tags</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>kargo-poc-tags</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kargo.akuity.io/color</span>: <span style=color:#ae81ff>green</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>requestedFreight</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>origin</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Warehouse</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kargo-poc-tags</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>sources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>stages</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>teststable-tags</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>verification</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>analysisTemplates</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kargo-poc-uat-analysis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>promotionTemplate</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-clone</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/service-cicd.git</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>checkout</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>branch</span>: <span style=color:#ae81ff>develop</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./src</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-clear</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./out/stages/uat</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>helm-update-image</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>as</span>: <span style=color:#ae81ff>update-image</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./src/chart/service/values-uat.yaml</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>images</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>image-registry.com/service-image</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>key</span>: <span style=color:#ae81ff>image.tag</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>value</span>: <span style=color:#ae81ff>Tag</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>helm-template</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>releaseName</span>: <span style=color:#ae81ff>service</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./src/chart/techcelerate-service</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>valuesFiles</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>./src/chart/techcelerate-service/values-uat.yaml</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>outPath</span>: <span style=color:#ae81ff>./out/stages/uat/manifests.yaml</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-commit</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>as</span>: <span style=color:#ae81ff>commit</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./out/stages/uat</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>messageFromSteps</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>update-image</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-push</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>as</span>: <span style=color:#ae81ff>push</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./out/stages/uat</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>generateTargetBranch</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-open-pr</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>as</span>: <span style=color:#ae81ff>open-pr</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/service-cicd.git</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>sourceBranchFromStep</span>: <span style=color:#ae81ff>push</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>targetBranch</span>: <span style=color:#ae81ff>develop</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>git-wait-for-pr</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/service-cicd.git</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>provider</span>: <span style=color:#ae81ff>gitlab</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>prNumberFromStep</span>: <span style=color:#ae81ff>open-pr</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>as</span>: <span style=color:#ae81ff>wait-pr</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses </span>: <span style=color:#ae81ff>argocd-update</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apps</span>:
</span></span><span style=display:flex><span>            - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-uat</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>argocd</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>sources</span>:
</span></span><span style=display:flex><span>                - <span style=color:#f92672>repoURL</span>: <span style=color:#ae81ff>https://github.com/service-cicd.git</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>desiredCommitFromStep</span>: <span style=color:#ae81ff>wait-pr</span>
</span></span></code></pre></div><p>Having selected the <em>uat-tags</em> <code>Stage</code>, I&rsquo;m no longer able to promote any arbitrary <code>Freight</code> but I have to select one that has been successfully deployed to <em>teststable-tags</em> before.</p><p><img alt="Promotion UI" src=/posts/kargo-filling-the-gap/ui-promotion.png>
Once I started the <code>Promotion</code> of a my <code>Freight</code> you can see what the PromotionTemplate from the <code>Stage</code> does. It creates a certain number of steps that will be executed and result in a Pull Request with the actual changes being created.</p><p><img alt="Stage Steps" src=/posts/kargo-filling-the-gap/stage-steps.png>
<img alt="Pull Request" src=/posts/kargo-filling-the-gap/pull-request.png>
Once the PR is merged, ArgoCD will take care to deploy the newest version of my release as usual and Kargo wills start the <code>AnalysisRun</code>.</p><h3 id=analysistemplates-are-the-key>AnalysisTemplates are the key
<a class=heading-link href=#analysistemplates-are-the-key><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kargo reuses the <code>AnalysisTemplate</code> resource of Argo Rollouts. This means, you must have the Argo Rollouts Operator installed on your cluster. It&rsquo;s a small price for the flexibility it offers you. Using <code>AnalysisTemplate</code>, you can choose from 11 predefined metrics providers to base your tests on, including arbitrary Kubernetes Jobs.</p><pre tabindex=0><code>apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: kargo-poc-uat
  namespace: kargo-poc
spec:
  metrics:
  - name: webmetric
    successCondition: result == &#34;Hello Audience!&#34;
    provider:
      web:
        url: &#34;https://my-service.kargo-demo.com/test&#34;
        timeoutSeconds: 20 # defaults to 10 seconds
        jsonPath: &#34;{$.message}&#34;
  - name: test
    provider:
      job:
        metadata:
        spec:
          backoffLimit: 1
          template:
            spec:
              containers:
              - name: test
                image: dockerhub.devops.telekom.de/grafana:k6
                command:
                ## Custom logic for a loadtest/e2e test?
                - k6 run loadtest.js
              restartPolicy: Never
</code></pre><p>Each <code>AnalysisTemplate</code> can be referenced in different stages of your deployment flow and will be executed afterwards. The results can be seen in the UI but you can obviously also query them from the Kubernetes resource.
<img alt=AnalysisRun src=/posts/kargo-filling-the-gap/analysisrun.png></p><p>Looking at this, you will be able to run <strong>any</strong> test for the deployments you made. Literally <strong>any</strong>. This is a great implementation to enable similar testing functionality as you get from linear pipelines in different stages.</p><h2 id=what-i-particularly-liked>What I particularly liked!
<a class=heading-link href=#what-i-particularly-liked><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=k8s-native>K8s native
<a class=heading-link href=#k8s-native><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kargo uses custom resources to realize all it&rsquo;s functionality. This is a pretty big plus because it fits very well into a K8s and operator-centric world we try to build.</p><h3 id=user-interface>User Interface
<a class=heading-link href=#user-interface><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The user interface is simple and lightweight. It does what it needs to do and makes very clear what is deployed and what&rsquo;s the history of your <code>Freight</code>. While I personally don&rsquo;t really need a user interface, I can see the potential value for our developers in it, getting a quick overview about their delivery lifecycle.</p><h3 id=cluster-separation>Cluster Separation
<a class=heading-link href=#cluster-separation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>If you are using an approach in which you have a management cluster and target clusters to run your actual workloads on, Kargo will integrate into this concept surprisingly well. The fact that all custom resources created by Kargo are applied and processed on your management cluster makes you completly independent of your target clusters.</p><h3 id=rendered-manifests>Rendered Manifests
<a class=heading-link href=#rendered-manifests><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kargo heavily features the rendered manifests approach. This means that the manifests of your sources are rendered and then committed into a branch or folder where your GitOps Operator fetches them. This brings additional benefits as small changes, e.g. in the version of a chart can lead to massive changes in the rendered manifests. Using this approach a Pull Request will always show you the <strong>actual</strong> impact of a change.</p><h3 id=argocd--rollouts-integration>ArgoCD & Rollouts Integration
<a class=heading-link href=#argocd--rollouts-integration><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kargo perfectly fits the spot between your delivery artifacts and GitOps. I particularly liked that it <strong>doesn&rsquo;t try to reinvent the wheel.</strong> It implements very well into existing solutions & workflows. Offering a simple ArgoCD sync mechanism is the perfect solution. The analysis capabilities of ArgoRollouts were not just reused but I also found that the verification steps in Kargo would respect the time it takes ArgoRollouts to deploy a full set of changes when using a step-wise deployment (e.g. canary). Perfect!</p><h3 id=communitymaintainers>Community/Maintainers
<a class=heading-link href=#communitymaintainers><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>For a couple of questions and issues I had to reach out to Kargo on Github. The speed in which I was getting helped with my issues was astonishing. It took maximum a few hours to get a helpful answer from the maintainers about my issues.</p><h3 id=installation>Installation
<a class=heading-link href=#installation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kargo is quite straight-forward to install. You can find the instructions in their documentation but it comes down to installing a helm chart. Similarly to related software like ArgoCD, the quality of the helm chart seems to be high, leaving almost nothing to wish for.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Kargo has released version 1.0 a few weeks ago. It&rsquo;s amazing what this product already offers. When we started building a new platform based on GitOps principles with a huge number of developers in mind, I had no idea how to solve the problem of securely promoting artifacts. Kargo brings <strong>a lot</strong> of good ideas and a surprising amount of implemented features even in version 1.0. Yes, the documentation is blurry and yes, there might be the one bug or the other. But for me, I see vast potential in this solution to solve a problem in a way I couldn&rsquo;t have imagined before.</p><p>During my poc, I found myself thinking &ldquo;Yes but I can still do this with tags in Git&rdquo;, until I tested the verification functionality. For me this seems to really solve a substantial problem with GitOps. Being able to verify your promoted resources right away, automatically without triggering some external system and Kargo keeping track of the results and even visualizing it for me is&mldr;
Call me a simple mind but I think it&rsquo;s mind-blowing.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Johannes Sonner
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>